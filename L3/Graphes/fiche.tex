\documentclass{article}      % Specifies the document class

\usepackage{amsmath}
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}

% ---------- add foreach ----------
\algnewcommand\algorithmicforeach{\textbf{for each}}
\algdef{S}[FOR]{ForEach}[1]{\algorithmicforeach\ #1\ \algorithmicdo}


% ---------- hack to remove indent ----------
% https://tex.stackexchange.com/questions/354564/how-to-remove-leading-indentation-from-algorithm
\usepackage{xpatch}
\makeatletter
\xpatchcmd{\algorithmic}
  {\ALG@tlm\z@}{\leftmargin\z@\ALG@tlm\z@}
  {}{}
\makeatother


\begin{document}

% ---------- Kruskal ---------- 
\begin{algorithm} \caption{Kruskal}
\begin{algorithmic}

\State \textbf{Entrée :} $G = (V, E, w)$, un graphe pondéré
\State \textbf{Sortie :} $T = (V, F)$ un Arbre Couvrant de Poids Minimum de $G$

\\ \State \textbf{Complexité :} $O(m\log_2(n) + n + m \cdot \alpha(n,m))$

\\ \State $L =$ la liste des arêtes triées par poids croissant

\\\ForEach {$e \in L$ (pris dans l'ordre)}
    \If {$e$ a ses deux extrémités dans deux Composantes Connexes différentes}
        \State $F := F \cup \{e\}$
    \EndIf
\EndFor

\\ \State \textbf{return} $F$
\end{algorithmic}
\end{algorithm}


% ---------- Jarnik-Prim ---------- 
\begin{algorithm} \caption{Jarnik-Prim}
\begin{algorithmic}

\State \textbf{Entrée :} $G = (V, E, w)$, un graphe pondéré
\State \textbf{Sortie :} $T = (V, F)$ un Arbre Couvrant de Poids Minimum de $G$

\\ \State \textbf{Complexité :} $O(n\log_2(n) + m)$ \textit{avec tas de Fibonacci} 

\\ \State Soit $S$ un sommet de $G$ quelconque

\\ \State $F := \emptyset$
\\ \State $C := \{S\}$

\\\ForEach {$e \in L$ (pris dans l'ordre)}
    \If {$e$ a ses deux extrémités dans deux Composantes Connexes différentes}
        \State $F := F \cup \{e\}$
    \EndIf
\EndFor

\\ \State \textbf{return} $F$
\end{algorithmic}
\end{algorithm}


% ---------- Bellman-Ford ---------- 
\begin{algorithm} \caption{Bellman \textit{(Bellman-Ford)}}
\begin{algorithmic}

\State \textbf{Entrée :} $G = (V, E)$, un graphe orienté valué et un sommet $S$
\State \textbf{Sortie :} $T$ une arborescence de plus court chemin ou Impossible si pas possible

\\ \State \textbf{Complexité :} $O(n\times m)$

\\ \State \textit{Partie 1 : Initialisation}
\ForEach {$v \in V(G)$}
    \State $d[v] := +\infty$
    \State $p[v] := \emptyset$
\EndFor


\\ \State \textit{Partie 2 : Calcul des plus courts chemins}
\For {$i=1$ to $|V(G)|-1$}
    \ForEach {arc $(u, v)$}
        \If {$(d[v] > d[u] + w(u ,v))$}
            \State $d[v] := d[u] + w(u, v)$
            \State $p[v] := u$
        \EndIf
    \EndFor
\EndFor


\\ \State \textit{Partie 3 : Détection de cycle de poids négatif}
\ForEach {arc $(u, v)$}
    \If {$(d[u] > d[u] + w(u ,v))$}
    \State \textbf{return} Impossible \textit{(cycle de poids négatif)}
    \EndIf
\EndFor

\\ \State \textbf{return} $p$
\end{algorithmic}
\end{algorithm}

\end{document}
